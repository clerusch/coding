\subsection{Quantum Error Model}
This way of encoding information however leaves a notable
issue:
It only detects bitflip, or Pauli-X, errors occurring on
the stored quantum information. While using Hadamard gates one
could trivially adapt this code to instead detect Pauli-Z errors,
it is not possible to use linear codes like the repetition code
to $simultaneously$ detect Pauli-X and Pauli-Z errors occurring.

Unlike classical computers, on a quantum computer the type of error
 is not limited
to a bitflip. Even for single-qubit states there exists an
infinite amount of differing possible errors, since when representing a single
qubit state as a vector on a Bloch sphere it immediately becomes apparent
that there are an infinite number of vectors on that sphere which are different
from it. It turns out though, that the change from one normalized
state to another is merely a sum of rotations.

Noise can therefore be modeled as a sum of Pauli gates.
Any single qubit error operator matrix E can be written as:
\begin{equation}
    E =
    \left(
    \begin{array}{cc}
        a & b \\
        c & d \\
    \end{array}
    \right) = 
    \alpha \mathbb{I} + \beta X + \delta Y + \gamma Z
\end{equation}
With an apropriate choice of $\alpha, \beta, \gamma, \delta$.
In effect, this means that with probability $\alpha$, the effect of the
error $E|\psi\rangle$ will be $\mathbb{I}$; with probability $\beta$ its effect
will be X, and so on.

It is hence sufficient to determine which of these errors $\mathbb{I}$, 
X, Y or Z has occurred, and we can apply the appropriate operator to return to the 
initial state.
Since an identity noise occurring is irrelevant to us, and XY as
well as ZY (anti-) commute, we need only detect for X and Z
errors occurring in order to detect any single qubit errors. 
(because of the commutation relation between \{X,Y\} and \{Y,Z\} a Y error
will appear as both an X and Z error).